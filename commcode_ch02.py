# -*- coding: utf-8 -*-
"""commCode_CH02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ypOsPMYUGTiLCsXagUq1nP7JhZKaAkOl
"""

#Fig:2-1 (audio visualization)
#importing required modules
from scipy.io import wavfile
import matplotlib.pyplot as plt
import numpy as np
#reading the sample audio rate and the data
rate, data = wavfile.read('harvard.wav')
print(f"number of channels = {data}")
length = data.shape[0] / rate
print(f"length = {length}s")
#plotting the audio time and amplitude
time = np.linspace(0., length, data.shape[0])
plt.plot(time, data, label="Audio")
plt.legend()
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.show()

#Fig:2-2 (continuous and discrete-time signal)
import numpy as np
import matplotlib.pyplot as plt
# Define a continuous-time signal function
def continuous_signal(t):
    return np.sin(2 * np.pi * t)
# Define a discrete-time signal
def discrete_signal(n):
    return np.sin(2 * np.pi * n / 10)
# Generate time values
t = np.linspace(-1, 1, 1000)
# Generate time indices
n = np.arange(-10, 10)
# Evaluate the signal at each time point
y1 = continuous_signal(t)
# Evaluate the signal at each time index
y2 = discrete_signal(n)
# Plot the continuous-time signal
plt.subplot(2, 1, 1)
plt.plot(t, y1)
plt.title('(a) Sinusoidal signal')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
# Plot the discrete-time signal
plt.subplot(2, 1, 2)
plt.stem(n, y2, basefmt='b')
plt.title('(b) Discrete-time sinusoidal signal')
plt.xlabel('$n$')
plt.ylabel('$x[n]$')
plt.tight_layout()
plt.show()

#Fig:2-3 (complex exponential signal)
import numpy as np
import matplotlib.pyplot as plt
import cmath
# Parameters
frequency = 1  # Frequency of the complex exponential signal
amplitude = 1  # Amplitude of the complex exponential signal
duration = 1.0  # Duration of the signal in seconds
sampling_rate = 1000  # Sampling rate in Hz
# Generate time values
t = np.arange(-1, duration, 1/sampling_rate)
# Generate complex exponential signal
complex_signal = amplitude * np.exp(1j * 2 * np.pi * frequency * t)
# Plot real, imaginary, magnitude, and phase parts
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 1)
plt.plot(t, np.real(complex_signal))
plt.title('(a) Real part')
plt.xlabel('$t$')
plt.ylabel('$x_{r}(t)$')
plt.subplot(2, 2, 2)
plt.plot(t, np.imag(complex_signal))
plt.title('(b) Imaginary part')
plt.xlabel('$t$')
plt.ylabel('$x_{i}(t)$')
plt.subplot(2, 2, 3)
plt.plot(t, np.abs(complex_signal))
plt.title('(c) Magnitude')
plt.xlabel('$t$')
plt.ylabel('$\\vert x(t) \\vert$')
plt.subplot(2, 2, 4)
plt.plot(t, np.angle(complex_signal))
plt.title('(d) Phase')
plt.xlabel('$t$')
plt.ylabel('$\\angle x(t)$')
plt.tight_layout()
plt.show()

#Fig:2-4 (deterministic and random signal)
import numpy as np
import matplotlib.pyplot as plt
# Parameters
frequency = 1  # Frequency of the sinusoidal signal
amplitude = 1  # Amplitude of the sinusoidal signal
duration = 1    # Duration of the signal in seconds
sampling_rate = 1000  # Sampling rate in Hz
# Time vector (deterministic signal)
t1 = np.linspace(-1, duration, int(sampling_rate * duration), endpoint=False)
# Generate the deterministic sinusoidal signal
deterministic_signal = amplitude * np.sin(2 * np.pi * frequency * t1)
# Generate random Gaussian white noise
random_signal = np.random.normal(0, 1, int(sampling_rate * duration))
# Time vector (random signal)
t2 = np.linspace(-1, duration, len(random_signal), endpoint=False)
# Plot the deterministic signal
plt.subplot(2, 1, 1)
plt.plot(t1, deterministic_signal)
plt.title('(a) Deterministic signal')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
# Plot the random signal
plt.subplot(2, 1, 2)
plt.plot(t2, random_signal)
plt.title('(b) Random signal')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.tight_layout()
plt.show()

#Fig:2-5 (causal, noncausal and anticausal signal)
import numpy as np
import matplotlib.pyplot as plt
# Parameters
duration = 1    # Duration of the signal in seconds
sampling_rate = 1000  # Sampling rate in Hz
# Time vector
t = np.linspace(-1, duration, int(sampling_rate * duration), endpoint=False)
# Time vector for anticausal signal (reversed time)
t_anticausal = np.flip(t)
# Generate causal signal (e.g., a step function)
causal_signal = np.heaviside(t, 1)
# Generate non-causal signal (e.g., a step function shifted to the left)
noncausal_signal = np.heaviside(t + 0.5, 1)
# Reverse the causal signal to create an anticausal signal
anticausal_signal = np.flip(causal_signal)
# Plot the causal signal
plt.subplot(3, 1, 1)
plt.plot(t, causal_signal)
plt.title('(a) Causal signal (unit-step signal)')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
# Plot the non-causal signal
plt.subplot(3, 1, 2)
plt.plot(t, noncausal_signal)
plt.title('(b) Noncausal signal (shifted unit-step signal)')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
# Plot the anticausal signal
plt.subplot(3, 1, 3)
#plt.plot(t_anticausal, causal_signal)
plt.plot(t, anticausal_signal)
plt.title('(c) Anticausal signal (reversed unit-step signal)')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.tight_layout()
plt.show()

#Fig:2-6 (even and odd signal)
import numpy as np
import matplotlib.pyplot as plt
# Parameters
duration = 2    # Duration of the signal in seconds
sampling_rate = 1000  # Sampling rate in Hz
# Time vector
t = np.linspace(-duration/2, duration/2, int(sampling_rate * duration))
# Generating an even signal (cosine function)
even_signal = np.cos(2 * np.pi * t)
# Generating an odd signal (sine function)
odd_signal = np.sin(2 * np.pi * t)
# Plot the even signal
plt.subplot(2, 1, 1)
plt.plot(t, even_signal)
plt.title('(a) Even signal: $x(t) = \cos(2\pi f_{0}t)$')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
# Plot the odd signal
plt.subplot(2, 1, 2)
plt.plot(t, odd_signal)
plt.title('(b) Odd signal: $x(t) = \sin(2\pi f_{0}t)$')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.tight_layout()
plt.show()

#Fig:2-7 (energy and power signal)
import numpy as np
import matplotlib.pyplot as plt
# Define a time vector
t = np.linspace(-10, 10, 1000)
# Energy signal: Gaussian pulse
energy_signal = np.exp(-t**2)
# Power signal: Sinusoidal signal
power_signal = np.sin(t)
# Calculate energy and power
energy = np.trapz(np.abs(energy_signal)**2, t)
power = np.mean(np.abs(power_signal)**2)
print("Energy of the signal:", energy)
print("Power of the signal:", power)
# Plotting
plt.plot(t, energy_signal, '--', label='Energy-type signal: $x(t) = e^{-t^{2}}$')
plt.plot(t, power_signal, label='Power-type signal: $x(t) = \sin(t)$')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.legend()
plt.show()

#Fig:2-8 (rectangular pulse)
import numpy as np
import matplotlib.pyplot as plt
def rectangular_pulse(half_duration, amplitude, total_duration):
    """
    Generates a rectangular pulse signal.

    Parameters:
        half_duration (float): Half duration of the pulse.
        amplitude (float): Amplitude of the pulse.
        total_duration (float): Total duration of the signal.

    Returns:
        numpy.ndarray: Array representing the rectangular pulse signal.
    """
    t = np.linspace(-total_duration/2, total_duration/2, num=1000)  # Time array, centered at zero
    start = -half_duration / 2  # Adjust start time so that half duration occurs at time = 0
    pulse = np.where((t >= start) & (t < start + half_duration), amplitude, 0)  # Generating the pulse
    return t, pulse
# Example usage:
half_pulse_duration = 1
pulse_amplitude = 1
total_duration = 4
time, pulse = rectangular_pulse(half_pulse_duration, pulse_amplitude, total_duration)
# Plotting
plt.plot(time, pulse)
plt.xlabel('$t$')
plt.ylabel('$\Pi(t)$')
plt.show()

#Fig:2-9 (triangular signal)
import numpy as np
import matplotlib.pyplot as plt
def triangular_signal(duration, amplitude, total_duration):
    """
    Generates a triangular signal.

    Parameters:
        duration (float): Duration of the triangular waveform.
        amplitude (float): Amplitude of the triangular waveform.
        total_duration (float): Total duration of the signal.

    Returns:
        numpy.ndarray: Array representing the triangular signal.
    """
    t = np.linspace(-total_duration/2, total_duration/2, num=1000)  # Time array, centered at zero
    half_duration = duration / 2
    slope = amplitude / half_duration

    # Generating the triangular signal
    signal = np.where((t >= -half_duration) & (t < 0), slope * (t + half_duration), 0)
    signal = np.where((t >= 0) & (t < half_duration), amplitude - slope * t, signal)

    return t, signal
# Example usage:
signal_duration = 2
signal_amplitude = 1
total_duration = 4
time, signal = triangular_signal(signal_duration, signal_amplitude, total_duration)
# Plotting
plt.plot(time, signal)
plt.xlabel('$t$')
plt.ylabel('$\Lambda(t)$')
plt.show()

#Fig:2-10 (sinc signal)
import numpy as np
import matplotlib.pyplot as plt
def sinc_signal(frequency, duration, total_duration):
    """
    Generates a sinc signal.

    Parameters:
        frequency (float): Frequency of the sinc signal.
        duration (float): Duration of the sinc signal.
        total_duration (float): Total duration of the signal.

    Returns:
        numpy.ndarray: Array representing the sinc signal.
    """
    t = np.linspace(-total_duration/2, total_duration/2, num=1000)  # Time array, centered at zero
    signal = np.sinc(frequency * t)  # Generating the sinc signal
    return t, signal
# Example usage:
signal_frequency = 1
signal_duration = 5
total_duration = 20
time, signal = sinc_signal(signal_frequency, signal_duration, total_duration)
# Plotting
plt.plot(time, signal)
plt.xlabel('$t$')
plt.ylabel('$\mathdefault{sinc}(t)$')
plt.show()

#Fig:2-11 (sign signal)
import numpy as np
import matplotlib.pyplot as plt
def signum_signal(x):
    """
    Computes the signum function of a given input.

    Parameters:
        x (numpy.ndarray): Input values.

    Returns:
        numpy.ndarray: Signum values corresponding to the input.
    """
    return np.sign(x)
# Example usage:
x_values = np.linspace(-5, 5, 1000)
signum_values = signum_signal(x_values)
# Plotting
plt.plot(x_values, signum_values)
plt.xlabel('$t$')
plt.ylabel('$\mathdefault{sgn}(t)$')
plt.show()

#Fig:2-12 (impulse signal)
import numpy as np
import matplotlib.pyplot as plt

def delta_signal(total_duration, impulse_time, epsilon):
    """
    Generates an approximation of the delta function using a rectangular pulse.

    Parameters:
        total_duration (float): Total duration of the signal.
        impulse_time (float): Time at which the impulse occurs.
        epsilon (float): Width of the rectangular pulse.

    Returns:
        numpy.ndarray: Array representing the delta function approximation.
    """
    t = np.linspace(-total_duration/2, total_duration/2, num=1000)  # Time array
    delta_approximation = np.where((t >= impulse_time - epsilon/2) & (t <= impulse_time + epsilon/2), 1/epsilon, 0)  # Generating the approximation
    return t, delta_approximation
# Example usage:
total_duration = 10
impulse_time = 0
epsilon = 1  # Width of the rectangular pulse
time, delta_approximation = delta_signal(total_duration, impulse_time, epsilon)
arrow_length = 1.0
# Plotting (approximation of the delta function using a rectangular pulse)
plt.subplot(2, 1, 1)
plt.plot(time, delta_approximation)
plt.xlabel('$t$')
plt.ylabel('$\delta(t)$')
plt.title('(a) The impulse signal as a limit (rectangular pulse)')
# Plotting (delta function as an arrow at a specified time)
plt.subplot(2, 1, 2)
plt.arrow(impulse_time, 0, 0, arrow_length, width = 0.01)
plt.xlim(impulse_time - 1, impulse_time + 1)
plt.ylim(-0.1, arrow_length + 0.1)
plt.xlabel('$t$')
plt.ylabel('$\delta(t)$')
plt.title('(b) A schematic representation of the impulse signal')
plt.tight_layout()
plt.show()

#Fig:2-13 (signal operation)
import numpy as np
import matplotlib.pyplot as plt
# Define the asymmetric dispersive pulse function
def asymmetric_dispersive_pulse(t, rise_time, fall_time, width, dispersion_coeff):
    gaussian_pulse = np.exp(-(t ** 2) / (2 * (width ** 2)))
    quadratic_phase = np.exp(1j * dispersion_coeff * (t ** 2))
    asymmetric_pulse = np.where(t < rise_time, t / rise_time, 1.0)
    asymmetric_pulse = np.where((t >= rise_time) & (t <= rise_time + fall_time), 1.0 - (t - rise_time) / fall_time, asymmetric_pulse)
    return gaussian_pulse * quadratic_phase * asymmetric_pulse
# Define time shifting function
def time_shift(signal, t, t_shift):
    t_shifted = t - t_shift
    return np.interp(t, t_shifted, signal, left=0, right=0)
# Define time reversal function
def time_reverse(signal, t):
    return np.flip(signal)
# Define time scaling function
def time_scale(signal, t, scaling_factor):
    t_scaled = t * scaling_factor
    return np.interp(t, t_scaled, signal, left=0, right=0)
# Create time array
t = np.linspace(-10, 10, 1000)
# Parameters for the asymmetric dispersive pulse
rise_time = 2
fall_time = 3
pulse_width = 4
dispersion_coeff = 0.1
# Create asymmetrical dispersive pulse
asym_dispersive_pulse = asymmetric_dispersive_pulse(t, rise_time, fall_time, pulse_width, dispersion_coeff)
# Plot original signal
plt.subplot(2, 2, 1)
plt.plot(t, np.abs(asym_dispersive_pulse))
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.title('(a) Original pulse')
# Time shifting
t_shift = 2
shifted_pulse = time_shift(np.abs(asym_dispersive_pulse), t, t_shift)
plt.subplot(2, 2, 2)
plt.plot(t, shifted_pulse)
plt.xlabel('$t$')
plt.ylabel('$x(t - t_{0})$')
plt.title('(b) Shifted pulse')
# Time reversal
reversed_pulse = time_reverse(np.abs(asym_dispersive_pulse), t)
plt.subplot(2, 2, 3)
plt.plot(t, reversed_pulse)
plt.xlabel('$t$')
plt.ylabel('$x(-t)$')
plt.title('(c) Reversed pulse')
# Time scaling
scaling_factor = 0.5
scaled_pulse = time_scale(np.abs(asym_dispersive_pulse), t, scaling_factor)
plt.subplot(2, 2, 4)
plt.plot(t, scaled_pulse)
plt.xlabel('$t$')
plt.ylabel('$x(at)$')
plt.title('(d) Scaled pulse')
plt.tight_layout()
plt.show()

#Fig:2-15 (convolution integral)
import numpy as np
import matplotlib.pyplot as plt
# Define the rectangular pulse function
def rect(t, width):
    return (np.abs(t) <= width/2).astype(float)
# Define the time range and step size
t = np.linspace(-5, 5, 1000)  # Time range
dt = t[1] - t[0]  # Time step
# Define parameters
width1 = 1.0  # Width of the first rectangular pulse
width2 = 1.0  # Width of the second rectangular pulse
shift = 0  # Shift of the second pulse to the right
# Define the input signals (two rectangular pulses)
x1 = rect(t, width1)
x2 = rect(t - shift, width2)
# Perform the convolution
conv_result = np.convolve(x1, x2, mode='same') * dt
# Plotting
plt.subplot(3, 1, 1)
plt.plot(t, x1)
plt.xlabel('$t$')
plt.ylabel('$\Pi(t)$')
plt.title('(a) First rectangular pulse')
plt.subplot(3, 1, 2)
plt.plot(t, x2)
plt.xlabel('$t$')
plt.ylabel('$\Pi(t)$')
plt.title('(b) Second rectangular pulse')
plt.subplot(3, 1, 3)
plt.plot(t, conv_result)
plt.xlabel('$t$')
plt.ylabel('$\Delta(t)$')
plt.title('(c) Convolution of two rectangular pulses: $\Pi(t) * \Pi(t)$')
plt.tight_layout()
plt.show()

#Fig:2-16--25 (Fourier analysis)
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import square
from scipy.integrate import quad
from scipy.fft import fft, fftfreq, fftshift

# Define impulse response function h(t)
def impulse_response(t):
    return np.where((t >= 0) & (t < 1), t, 0)

# Define function to compute Fourier transform H(f) using numerical integration
def fourier_transform(f):
    integrand = lambda t: impulse_response(t) * np.exp(-2j * np.pi * f * t)
    result, _ = quad(integrand, 0, 1)
    return result

# Define function to compute Fourier transform H(n/T0) using numerical integration
# def fourier_transform_harmonic(n, T0):
#     def integrand(t):
#         return impulse_response(t) * np.exp(-2j * np.pi * n * t / T0)
#     result, _ = quad(integrand, 0, T0)
#     return result / T0
def fourier_transform_harmonic(n, T0):
  integrand = lambda t: impulse_response(t) * np.exp(-2j * np.pi * n * t / T0)
  result, _ = quad(integrand, 0, 1)
  return result

# Parameters
period = 2.0  # Period of the pulse train in seconds
duty_cycle = 0.5  # Duty cycle of the pulse train
duration = 4.0  # Total duration of the signal in seconds
sampling_rate = 1000  # Sampling rate of the signal in Hz
time_shift = -0.5  # Time shift in seconds
dc_offset = 1.0  # DC offset
signal_scale = 0.5  # Signal scaling factor
n_max = 4  # Maximum coefficient to compute
tau = 1

# Time array
t = np.linspace(-4, duration, int(sampling_rate * duration), endpoint=False)

# Generate rectangular pulse train with time shift, DC offset, and scaled signal
pulse_train = square(2 * np.pi * (t - time_shift) / period, duty=duty_cycle)
pulse_train = signal_scale*(pulse_train + dc_offset)

# Compute Fourier series coefficients xn
n_values = np.arange(-n_max, n_max+1, 1)
xn = (tau / period) * np.sinc(n_values * tau / period)
# print("xn:", xn)
# for n, coef in enumerate(xn):
#     print("x{}:".format(n - n_max), xn[n])

# Compute Fourier series expansion (n = [-4 4])
x = xn[4]* np.exp(1j*2*np.pi*0* t/period) + xn[0]* np.exp(1j*2*np.pi*-4* t/period) \
+ xn[1]* np.exp(1j*2*np.pi*-3* t/period) + xn[2]* np.exp(1j*2*np.pi*-2* t/period) \
+ xn[3]* np.exp(1j*2*np.pi*-1* t/period) + xn[5]* np.exp(1j*2*np.pi*1* t/period) \
+ xn[6]* np.exp(1j*2*np.pi*2* t/period) + xn[7]* np.exp(1j*2*np.pi*3* t/period) \
+ xn[8]* np.exp(1j*2*np.pi*4* t/period)

# Compute magnitude and phase spectra of xn
#harmonics = np.arange(-n_max, n_max + 1)
mag = np.abs(xn)
ph = np.angle(xn)
# print("magnitude of xn:", mag)
# for n, coef in enumerate(mag):
#     print("mag{}:".format(n - n_max), mag[n])
# print("phase of xn:", ph)
# for n, coef in enumerate(ph):
#     print("ph{}:".format(n - n_max), ph[n])

# Generate impulse response
#h = [t1 if 0 <= t1 < 1 else 0 for t1 in t]
h = impulse_response(t)

# # Compute frequency response H(f) using FFT
# N = len(t) #no. samples (sampling_rate*duration = length of t)
# H = fft(h)
# freq = fftfreq(N, 1 / sampling_rate)
# xf = fftshift(freq)
# yf = fftshift(H)

# Compute frequency response H(f) using numerical integration
f = np.linspace(-5, 5, 1000)  # frequency range
H_f = np.array([fourier_transform(freq) for freq in f])

# Compute frequency response H(n/T0) using numerical integration for each harmonic
T0 = period
#harmonic_numbers = np.arange(-4, 5)  # Harmonic numbers from -4 to 4
harmonic_numbers = n_values
#frequencies_harmonic = harmonic_numbers / T0    # Frequencies in terms of harmonics
H_f_integral = np.array([fourier_transform_harmonic(n, T0) for n in harmonic_numbers])

# Compute output y_n using numerical integration
y_n_integral = xn * H_f_integral

# Plot the pulse train
plt.plot(t, pulse_train)
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
#plt.title('Rectangular Pulse Train')
plt.show()

# Plot Fourier series coefficients x_n and Fourier series expansion
plt.subplot(2, 1, 1)
plt.stem(n_values, xn)
plt.xlabel('$n$')
plt.ylabel('$x_{n}$')
plt.title('(a) Fourier-series coefficients')
plt.subplot(2, 1, 2)
plt.plot(t, pulse_train, t, x,'--')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.xlim([-2, 2])
plt.title('(b) Fourier-series approximations')
plt.tight_layout()
plt.show()

# Plot magnitude and phase spectra of x(t)
plt.subplot(2, 1, 1)
plt.stem(n_values, mag, basefmt='b', markerfmt='bo', linefmt='b--')
plt.title('(a) Magnitude spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\vert x_{n} \\vert$')
plt.subplot(2, 1, 2)
plt.stem(n_values, ph, basefmt='r', markerfmt='ro', linefmt='r--')
plt.title('(b) Phase spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\angle{x_{n}}$')
plt.tight_layout()
plt.show()

# Plot the impulse response h(t)
plt.plot(t, h)
plt.xlabel('$t$')
plt.ylabel('$h(t)$')
#plt.title('Rectangular Pulse Train')
plt.show()

# # Plot magnitude of H(f) using FFT
# #plt.plot(freq, np.abs(H))
# plt.plot(xf, 1.0/N * np.abs(yf))
# plt.xlabel('$f$')
# plt.ylabel('$\\vert H(f) \\vert$')
# plt.xlim([-20, 20])
# plt.show()

# Plot transfer function/frequency response H(f) using numerical integration
#plt.plot(f, np.abs(H_f))
plt.plot(f, H_f)
plt.xlabel('$f$')
plt.ylabel('$H(f)$')
plt.show()

# Plot magnitude and phase of of H(f) using numerical integration
plt.subplot(2, 1, 1)
plt.plot(f, np.abs(H_f))
plt.title('(a) Magnitude')
plt.xlabel('$f$')
plt.ylabel('$\\vert H(f) \\vert$')
plt.subplot(2, 1, 2)
plt.plot(f, np.angle(H_f))
plt.title('(b) Phase')
plt.xlabel('$f$')
plt.ylabel('$\\angle{H(f)}$')
plt.tight_layout()
plt.show()

# Plot Fourier-series coefficients of H(n/T_{0}) using numerical integration
plt.stem(harmonic_numbers, H_f_integral)
plt.xlabel('$n$')
plt.ylabel('$H\\left(\\frac{n}{T_{0}}\\right)$')
plt.show()

# Plot discrete spectrum of of H(n/T_{0}) using numerical integration
plt.subplot(2, 1, 1)
plt.stem(harmonic_numbers, np.abs(H_f_integral), basefmt='b', markerfmt='bo', linefmt='b--')
plt.title('(a) Magnitude spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\vert H\\left(\\frac{n}{T_{0}}\\right) \\vert$')
plt.subplot(2, 1, 2)
plt.stem(harmonic_numbers, np.angle(H_f_integral), basefmt='r', markerfmt='ro', linefmt='r--')
plt.title('(b) Phase spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\angle{H\\left(\\frac{n}{T_{0}}\\right)}$')
plt.tight_layout()
plt.show()

# Plot Fourier series coefficients of output y_n using numerical integration
plt.stem(harmonic_numbers, y_n_integral)
plt.xlabel('$n$')
plt.ylabel('$y_{n}$')
plt.show()

# Plot discrete spectrum of output y(t) using numerical integration
plt.subplot(2, 1, 1)
plt.stem(harmonic_numbers, np.abs(y_n_integral), basefmt='b', markerfmt='bo', linefmt='b--')
plt.title('(a) Magnitude spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\vert y_{n} \\vert$')
plt.subplot(2, 1, 2)
plt.stem(harmonic_numbers, np.angle(y_n_integral), basefmt='r', markerfmt='ro', linefmt='r--')
plt.title('(b) Phase spectrum')
plt.xlabel('$n$')
plt.ylabel('$\\angle{y_{n}}$')
plt.tight_layout()
plt.show()

#Fig:2-26 (Fourier transform of real signal)
import numpy as np
import matplotlib.pyplot as plt

# Define the rectangular pulse function
def x_rect(t, T):
    return np.where((t >= 0) & (t <= T), 1, 0)

# Define the Fourier transform function
def X(f, t, x):
    return np.trapz(x(t) * np.exp(-2j * np.pi * f * t), t)

# Define the time range
t_min = -5
t_max = 5
num_samples = 1000
t = np.linspace(t_min, t_max, num_samples)

# Define the width of the rectangular pulse
T = 1

# Compute the rectangular pulse function x(t)
x_values = x_rect(t, T)

# Compute the Fourier transform X(f)
f_min = -5
f_max = 5
num_points = 1000
f = np.linspace(f_min, f_max, num_points)

X_values = np.array([X(freq, t, lambda t: x_rect(t, T)) for freq in f])

# Plot the rectangular pulse function in time domain
# plt.figure(figsize=(10, 7))
# plt.subplot(3, 1, 1)
# plt.plot(t, x_values, color='blue')
# plt.title('Rectangular Pulse Function in Time Domain')
# plt.xlabel('Time (s)')
# plt.ylabel('Amplitude')

# Plot the magnitude and phase of X(f)
plt.subplot(2, 1, 1)
plt.plot(f, np.abs(X_values))
plt.title('(a) Magnitude')
plt.xlabel('$f$')
plt.ylabel('$\\vert X(f) \\vert$')
plt.subplot(2, 1, 2)
plt.plot(f, np.angle(X_values))
plt.title('(b) Phase')
plt.xlabel('$f$')
plt.ylabel('$\\angle{X(f)}$')
plt.tight_layout()
plt.show()

#Fig:2-27 (Fourier transform of LTI system)
import numpy as np
import matplotlib.pyplot as plt

# Define the sinc function
def sinc(t):
    return np.sinc(t / np.pi)

# Define the Fourier transform of sinc(t)
def Xf(f):
    return np.where(np.abs(f) <= 10, 0.2, 0)

# Define the Fourier transform of sinc(2t)
def Hf(f):
    return np.where(np.abs(f) <= 4, 0.5, 0)

# Define the Fourier transform of the convolution
def Yf(f):
    return Xf(f) * Hf(f)

# Generate frequency values
f = np.linspace(-15, 15, 1000)

# Compute Fourier transforms
X = Xf(f)
H = Hf(f)
Y = Yf(f)

# Plot the Fourier transforms
plt.subplot(3, 1, 1)
plt.plot(f, X)
plt.title('(a) Input signal')
plt.xlabel('$f$')
plt.ylabel('$X(f)$')
plt.subplot(3, 1, 2)
plt.plot(f, H)
plt.title('(b) Frequency response')
plt.xlabel('$f$')
plt.ylabel('$H(f)$')
plt.subplot(3, 1, 3)
plt.plot(f, Y)
plt.title('(c) Output signal')
plt.xlabel('$f$')
plt.ylabel('$Y(f)$')
plt.tight_layout()
plt.show()

#Fig:2-28--32 (Lowpass/bandpass signals)
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt

# Parameters
duration = 1  # Duration of audio signal in seconds
sampling_rate = 10000  # Sampling rate in Hz
f1 = 5  # Frequency of the audio signal in Hz
f2 = 10
carrier_frequency = 100  # Carrier frequency in Hz
amplitude = 1  # Amplitude of the carrier signal

# Function to compute Fourier transform using numerical integration with np.trapz
def fourier_transform(signal, frequencies, time):
    X = np.zeros_like(frequencies, dtype=np.complex128)
    for i, freq in enumerate(frequencies):
        complex_exp = np.exp(-2j * np.pi * freq * time)
        X[i] = np.trapz(signal * complex_exp, time)
    return X

# Low-pass filtering (envelope detection)
def butter_lowpass_filter(data, cutoff_freq, fs, order=5):
    nyquist_freq = 0.5 * fs
    normal_cutoff = cutoff_freq / nyquist_freq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    filtered_data = filtfilt(b, a, data)
    return filtered_data

# Time array
t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)

# Define the baseband (original) signal as a sum of cosine waves
audio_signal = np.cos(2 * np.pi * f1 * t) + 2 * np.cos(2 * np.pi * f2 * t)

# Define the carrier signal
carrier_signal = amplitude * np.cos(2 * np.pi * carrier_frequency * t)

# Define the bandpass signal
bandpass_signal = audio_signal * carrier_signal

# Compute I and Q components
I_signal = bandpass_signal * np.cos(2 * np.pi * carrier_frequency * t)
Q_signal = bandpass_signal * np.sin(2 * np.pi * carrier_frequency * t)

# Frequency range
freq_range = np.linspace(-sampling_rate / 2, sampling_rate / 2, len(t))

# Compute Fourier transform of the baseband (original) signal
spectrum_baseband = fourier_transform(audio_signal, freq_range, t)

# Compute Fourier transform of the bandpass signal
spectrum_bandpass = fourier_transform(bandpass_signal, freq_range, t)

# Envelope detection
cutoff_freq = 100  # Set cutoff frequency for low-pass filter
order = 8  # Set filter order
I_envelope = butter_lowpass_filter(I_signal, cutoff_freq, sampling_rate, order)
Q_envelope = butter_lowpass_filter(Q_signal, cutoff_freq, sampling_rate, order)

# Compute envelope (magnitude) of the bandpass signal
envelope_bandpass_signal = np.sqrt(I_envelope**2 + Q_envelope**2)
#envelope_bandpass_signal = np.sqrt(I_signal**2 + Q_signal**2)

# Compute phase of the bandpass signal
phase_bandpass_signal = np.arctan2(Q_envelope, I_envelope)
#phase_bandpass_signal = np.arctan2(Q_signal, I_signal)

# Lowpass equivalent of bandpass signal
lowpass_equivalent_signal = I_envelope + 1j * Q_envelope
#lowpass_equivalent_signal = I_signal + 1j * Q_signal
#lowpass_equivalent_signal = envelope_bandpass_signal * np.exp(1j * phase_bandpass_signal)

# Compute Fourier transform of the lowpass equivalent signal
spectrum_lowpass_equivalent = fourier_transform(lowpass_equivalent_signal, freq_range, t)

# Plot baseband (original), carrier, bandpass signals
plt.subplot(3, 1, 1)
plt.plot(t, audio_signal)
plt.title('(a) Baseband (original) signal')
plt.xlabel('$t$')
plt.ylabel('$s(t)$')

plt.subplot(3, 1, 2)
plt.plot(t, carrier_signal)
plt.title('(b) Carrier signal')
plt.xlabel('$t$')
plt.ylabel('$c(t)$')

plt.subplot(3, 1, 3)
plt.plot(t, bandpass_signal)
plt.title('(c) Bandpass signal')
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
plt.tight_layout()
plt.show()

# Plot signal spectrum
plt.subplot(2, 1, 1)
plt.plot(freq_range, np.abs(spectrum_baseband))
plt.xlim([-carrier_frequency-100, carrier_frequency+100])
plt.title('(a) Baseband (original) signal spectrum')
plt.xlabel('$f$')
plt.ylabel('$S(f)$')

plt.subplot(2, 1, 2)
plt.plot(freq_range, np.abs(spectrum_bandpass))
plt.xlim([-carrier_frequency-100, carrier_frequency+100])
plt.title('(b) Bandpass signal spectrum')
plt.xlabel('$f$')
plt.ylabel('$X(f)$')
plt.tight_layout()
plt.show()

# Plot I and Q components
plt.subplot(2, 1, 1)
plt.plot(t, I_signal)
plt.title('(a) In-phase component')
plt.xlabel('$t$')
plt.ylabel('$x_{c}(t)$')

plt.subplot(2, 1, 2)
plt.plot(t, Q_signal)
plt.title('(b) Quadrature component')
plt.xlabel('$t$')
plt.ylabel('$x_{s}(t)$')
plt.tight_layout()
plt.show()

# Plot envelope and phase of the I and Q components
# plt.subplot(2, 1, 1)
# plt.plot(t, I_envelope)
# plt.title('(a) In-phase envelope')
# plt.xlabel('$t$')
# plt.ylabel('$A_{x_{c}}(t)$')

# plt.subplot(2, 1, 2)
# plt.plot(t, Q_envelope)
# plt.title('(b) Quadrature envelope')
# plt.xlabel('$t$')
# plt.ylabel('$A_{x_{s}}(t)$')
# plt.tight_layout()
# plt.show()

# Plot envelope and phase of the bandpass signal
plt.subplot(2, 1, 1)
plt.plot(t, envelope_bandpass_signal)
plt.title('(a) Envelope of bandpass signal')
plt.xlabel('$t$')
plt.ylabel('$A(t)$')
plt.subplot(2, 1, 2)
plt.plot(t, phase_bandpass_signal)
plt.title('(b) Phase of bandpass signal')
plt.xlabel('$t$')
plt.ylabel('$\\theta(t)$')
plt.tight_layout()
plt.show()

# Plot lowpass equivalent signal and its spectrum
plt.subplot(2, 1, 1)
plt.plot(t, lowpass_equivalent_signal.real)
plt.title('(a) Lowpass equivalent of bandpass signal')
plt.xlabel('$t$')
plt.ylabel('$x_{l}(t)$')
plt.subplot(2, 1, 2)
plt.plot(freq_range, np.abs(spectrum_lowpass_equivalent))
plt.title('(b) Lowpass equivalent signal spectrum')
plt.xlabel('$f$')
plt.ylabel('$X_{l}(f)$')
plt.xlim([-carrier_frequency-100, carrier_frequency+100])
plt.tight_layout()
plt.show()